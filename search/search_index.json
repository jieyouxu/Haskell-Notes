{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Haskell Notes \u00b6 Some notes on Haskell based on Haskell Programming from First Principles .","title":"Home"},{"location":"#haskell-notes","text":"Some notes on Haskell based on Haskell Programming from First Principles .","title":"Haskell Notes"},{"location":"1-foundation/notes/","text":"Foundations \u00b6 A calculus is a method of calculating or reasoning . Lambda calculus formalizes effective computability . Functional Programming \u00b6 Functional programming (FP) is a programming paradigm relying on functions modeled on mathematical functions . Programs in FP are composed from expressions , which can be: Values ; Variables ; Functions . Functions are expressions which are applied to an argument / input , which can be reduced or evaluated . Functions are first-class in Haskell, such that they can be used as: Values ; Passed as arguments / inputs to other functions. Purity in FP can mean referential transparency : Given a function f f , if it is given the same input x x , it will always return the same output y y , like a mathematical function. Abstraction allows writing shorter code by extracting common/repeated constructs into more reusable, generic code. High levels of abstraction allows programmers to compose programs from separate functions. Functions \u00b6 A function is the relation between a set of possible inputs and a set of possible outputs . Function application maps input(s) to an output. Example Given some function f f , with the input set ( domain ) \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} and the output set ( codomain ) \\{ A, B, C \\} \\{ A, B, C \\} , with f f defined as \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} Then f f is referentially transparent \u2014 for instance, when f f receives input 1 1 it always outputs A A . This ensures that the function is in fact predictable . Note For OOP languages like Java, objects often constitute of shared mutable state. This can make testing and debugging very difficult because for some input, a method on an object does not necessarily return the same output. The previous example only defined a mapping, but not necessarily a relationship between its input and output. Example Given some function f f , let it be defined as f(x) = \\underbrace{x + 1}_{\\text{function body}} f(x) = \\underbrace{x + 1}_{\\text{function body}} The function f f takes a single named argument x x . f f describes the relationship between the input x x and output (which is described in the function body ). Upon applying the function f f , we substitute its argument x x for a concrete value, for instance 1 1 . Then f(1) = 1 + 1 = 2 f(1) = 1 + 1 = 2 . This establishes a mapping f(1) \\mapsto 2 f(1) \\mapsto 2 . Structure of Lambda Calculus \u00b6 The lambda calculus comprises three lambda terms : Expressions Variables Abstractions An expression is either one of the three lambda terms or a combination of them (hence an inductive definition). The simplest expression is a single variable, which has no meaning or value and are simply placeholder names for inputs. An abstraction is a function ; it has A head (a lambda ) A body And is applied to an argument , which is an input value. Hereafter a lambda abstraction will be referred to as a \" lambda \" or an \" abstraction \" for brevity. Abstraction An abstraction is built from a head and a body . The head of a function is a \\lambda \\lambda followed by a variable name. The body is another expression . Simple abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x The variable x x named in the head is the abstraction's parameter which binds all occurrences of x x in the body. When the abstraction is applied with an input value v v given to x x , all occurrences of x x in the body takes on that input value v v . In the abstraction, the \\lambda x \\lambda x part is the head , the x x in the head is the single parameter , and the x x to the right of the \\ldotp \\ldotp is the body. Note that the x x in the body is bound by the parameter of the same name. The dot \\ldotp \\ldotp acts as a separator. Anonymous function The previous example's lambda abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x does not have a name, hence it is anonymous . Hence it cannot be called by name. It is called an abstraction since it is a generalization of a concrete problem, and names given to it allows abstraction \u2014 abstracting away from tiny details to simplify the cognitive burden and facilitates code reuse. By using named variables, we can reuse the abstraction for potentially many instances of similar problems. Alpha Equivalence \u00b6 For some lambda abstraction such as \\lambda x \\ldotp x \\lambda x \\ldotp x The named variable x x has no semantic meaning apart from being a placeholder for input values. Hence, it might as well be a a or b b or c c , etc. This means that the lambda terms \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta Have alpba equivalence \u2014 they are the same function. Beta Reduction \u00b6 Upon applying a function to an argument, all occurrences of the bound variable within the body (that is the parameter) are substituted with the input expression. The head can safely be eliminated as it only serves the purpose of binding a name to the parameter. Example For the abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x If the abstraction is applied to 2 2 , then: Substitute 2 2 for every occurrence of x x in the body. Eliminate the head. That is, \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} Identity function The previous example function \\lambda x \\ldotp x \\lambda x \\ldotp x is the identity function since it simply returns whatever input expression was given to it. This is like f(x) = x f(x) = x . To denote precedence, let parentheses () () be used to group the body expression of an abstraction. Parentheses showing precedence (\\lambda x \\ldotp x + 1) (\\lambda x \\ldotp x + 1) Here the body expression is x + 1 x + 1 . A lambda abstraction can also be applied to another lambda abstraction. Square brackets [] [] shall be used to denote substitution. Square brackets showing substitution \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} Associativity of application Applications in lambda calculus are left associative from the right to the left. Left associativity of lambda application (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z This expression may be reduced as \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned} Free Variables \u00b6 The head of an lambda abstraction provides information on which named variable is bounded to be in scope when the function is applied. Those variables in the expression body which are not named in the head are free variables . Free variable In the lambda abstraction \\lambda x \\ldotp x y \\lambda x \\ldotp x y y y is a free variable as it is not named in the head. It cannot be reduced when the function is applied to an argument. Applying lambda abstraction to a variable The lambda abstraction \\lambda x \\ldotp x y \\lambda x \\ldotp x y Can be applied to some variable z z (\\lambda x \\ldotp x y) z (\\lambda x \\ldotp x y) z . The lambda can be applied to the argument z z . (\\lambda [x \\coloneq z] \\ldotp x y) (\\lambda [x \\coloneq z] \\ldotp x y) . x x is the bound variable and its instances shall be replaced by z z , with the head being eliminated. z y z y . Head was eliminated and no more heads are left, and since z z and y y are free variables no further reductions may be applied. Multiple Arguments \u00b6 Each lambda may have only one parameter and thus can only accept one argument. Should an expression require multiple arguments, it must be composed from multiple nested heads. When such composite lambda is applied once, the leftmost/ outmost head is first eliminated, and the next is then applied. Such method of having nested heads is termed currying . Currying An abstraction such as \\lambda x y \\ldotp x y \\lambda x y \\ldotp x y Is shorthand for \\lambda x \\ldotp (\\lambda y \\ldotp x y) \\lambda x \\ldotp (\\lambda y \\ldotp x y) When the first argument x x is applied, x x is bound and the outer lambda is eliminated to become \\lambda y \\ldotp x y \\lambda y \\ldotp x y with some applied x x value. Reduction of a multi-argument lambda Let \\lambda x y \\ldotp x y \\lambda x y \\ldotp x y Be applied to 1 1 and 2 2 respectively. Then \\begin{aligned} (\\lambda x y \\ldotp x y)\\ 1\\ 2 & \\\\ (\\lambda x \\ldotp (\\lambda y \\ldotp x y))\\ 1\\ 2 & \\\\ [x \\coloneq 1] & \\\\ (\\lambda y \\ldotp 1 y)\\ 2 & \\\\ [y \\coloneq 2] & \\\\ 1\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x y \\ldotp x y)\\ 1\\ 2 & \\\\ (\\lambda x \\ldotp (\\lambda y \\ldotp x y))\\ 1\\ 2 & \\\\ [x \\coloneq 1] & \\\\ (\\lambda y \\ldotp 1 y)\\ 2 & \\\\ [y \\coloneq 2] & \\\\ 1\\ 2 & \\\\ \\end{aligned} Beta Normal Form \u00b6 A beta normal form (BNF) is when some lambda expression cannot be beta reduced any further - a fully evaluated expression or program. Combinator \u00b6 A combinator is a lambda term with no free variables, and only serve to combine given arguments. Valid combinators \\lambda x \\ldotp x \\lambda x \\ldotp x x x is the only variable and is bound. \\lambda x y \\ldotp x \\lambda x y \\ldotp x \\lambda x y z \\ldotp x z (y z) \\lambda x y z \\ldotp x z (y z) Not combinators \\lambda y \\ldotp x \\lambda y \\ldotp x x x is a free variable. \\lambda x \\ldotp x z \\lambda x \\ldotp x z z z is a free variable. Divergence \u00b6 Some lambda terms do not reduce to a beta normal form because they diverge . Divergence refers to the evaluation process never terminates. Omega lambda term (diverging) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) x x in first lambda's head becomes second lambda. ([x \\coloneq (\\lambda x \\ldotp x x)]) x x ([x \\coloneq (\\lambda x \\ldotp x x)]) x x (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) Substitution of (\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x) for x x causes the original lambda to reappear and thus evaluation cannot terminate.","title":"Foundation"},{"location":"1-foundation/notes/#foundations","text":"A calculus is a method of calculating or reasoning . Lambda calculus formalizes effective computability .","title":"Foundations"},{"location":"1-foundation/notes/#functional-programming","text":"Functional programming (FP) is a programming paradigm relying on functions modeled on mathematical functions . Programs in FP are composed from expressions , which can be: Values ; Variables ; Functions . Functions are expressions which are applied to an argument / input , which can be reduced or evaluated . Functions are first-class in Haskell, such that they can be used as: Values ; Passed as arguments / inputs to other functions. Purity in FP can mean referential transparency : Given a function f f , if it is given the same input x x , it will always return the same output y y , like a mathematical function. Abstraction allows writing shorter code by extracting common/repeated constructs into more reusable, generic code. High levels of abstraction allows programmers to compose programs from separate functions.","title":"Functional Programming"},{"location":"1-foundation/notes/#functions","text":"A function is the relation between a set of possible inputs and a set of possible outputs . Function application maps input(s) to an output. Example Given some function f f , with the input set ( domain ) \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} and the output set ( codomain ) \\{ A, B, C \\} \\{ A, B, C \\} , with f f defined as \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} Then f f is referentially transparent \u2014 for instance, when f f receives input 1 1 it always outputs A A . This ensures that the function is in fact predictable . Note For OOP languages like Java, objects often constitute of shared mutable state. This can make testing and debugging very difficult because for some input, a method on an object does not necessarily return the same output. The previous example only defined a mapping, but not necessarily a relationship between its input and output. Example Given some function f f , let it be defined as f(x) = \\underbrace{x + 1}_{\\text{function body}} f(x) = \\underbrace{x + 1}_{\\text{function body}} The function f f takes a single named argument x x . f f describes the relationship between the input x x and output (which is described in the function body ). Upon applying the function f f , we substitute its argument x x for a concrete value, for instance 1 1 . Then f(1) = 1 + 1 = 2 f(1) = 1 + 1 = 2 . This establishes a mapping f(1) \\mapsto 2 f(1) \\mapsto 2 .","title":"Functions"},{"location":"1-foundation/notes/#structure-of-lambda-calculus","text":"The lambda calculus comprises three lambda terms : Expressions Variables Abstractions An expression is either one of the three lambda terms or a combination of them (hence an inductive definition). The simplest expression is a single variable, which has no meaning or value and are simply placeholder names for inputs. An abstraction is a function ; it has A head (a lambda ) A body And is applied to an argument , which is an input value. Hereafter a lambda abstraction will be referred to as a \" lambda \" or an \" abstraction \" for brevity. Abstraction An abstraction is built from a head and a body . The head of a function is a \\lambda \\lambda followed by a variable name. The body is another expression . Simple abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x The variable x x named in the head is the abstraction's parameter which binds all occurrences of x x in the body. When the abstraction is applied with an input value v v given to x x , all occurrences of x x in the body takes on that input value v v . In the abstraction, the \\lambda x \\lambda x part is the head , the x x in the head is the single parameter , and the x x to the right of the \\ldotp \\ldotp is the body. Note that the x x in the body is bound by the parameter of the same name. The dot \\ldotp \\ldotp acts as a separator. Anonymous function The previous example's lambda abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x does not have a name, hence it is anonymous . Hence it cannot be called by name. It is called an abstraction since it is a generalization of a concrete problem, and names given to it allows abstraction \u2014 abstracting away from tiny details to simplify the cognitive burden and facilitates code reuse. By using named variables, we can reuse the abstraction for potentially many instances of similar problems.","title":"Structure of Lambda Calculus"},{"location":"1-foundation/notes/#alpha-equivalence","text":"For some lambda abstraction such as \\lambda x \\ldotp x \\lambda x \\ldotp x The named variable x x has no semantic meaning apart from being a placeholder for input values. Hence, it might as well be a a or b b or c c , etc. This means that the lambda terms \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta Have alpba equivalence \u2014 they are the same function.","title":"Alpha Equivalence"},{"location":"1-foundation/notes/#beta-reduction","text":"Upon applying a function to an argument, all occurrences of the bound variable within the body (that is the parameter) are substituted with the input expression. The head can safely be eliminated as it only serves the purpose of binding a name to the parameter. Example For the abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x If the abstraction is applied to 2 2 , then: Substitute 2 2 for every occurrence of x x in the body. Eliminate the head. That is, \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} Identity function The previous example function \\lambda x \\ldotp x \\lambda x \\ldotp x is the identity function since it simply returns whatever input expression was given to it. This is like f(x) = x f(x) = x . To denote precedence, let parentheses () () be used to group the body expression of an abstraction. Parentheses showing precedence (\\lambda x \\ldotp x + 1) (\\lambda x \\ldotp x + 1) Here the body expression is x + 1 x + 1 . A lambda abstraction can also be applied to another lambda abstraction. Square brackets [] [] shall be used to denote substitution. Square brackets showing substitution \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} Associativity of application Applications in lambda calculus are left associative from the right to the left. Left associativity of lambda application (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z This expression may be reduced as \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned}","title":"Beta Reduction"},{"location":"1-foundation/notes/#free-variables","text":"The head of an lambda abstraction provides information on which named variable is bounded to be in scope when the function is applied. Those variables in the expression body which are not named in the head are free variables . Free variable In the lambda abstraction \\lambda x \\ldotp x y \\lambda x \\ldotp x y y y is a free variable as it is not named in the head. It cannot be reduced when the function is applied to an argument. Applying lambda abstraction to a variable The lambda abstraction \\lambda x \\ldotp x y \\lambda x \\ldotp x y Can be applied to some variable z z (\\lambda x \\ldotp x y) z (\\lambda x \\ldotp x y) z . The lambda can be applied to the argument z z . (\\lambda [x \\coloneq z] \\ldotp x y) (\\lambda [x \\coloneq z] \\ldotp x y) . x x is the bound variable and its instances shall be replaced by z z , with the head being eliminated. z y z y . Head was eliminated and no more heads are left, and since z z and y y are free variables no further reductions may be applied.","title":"Free Variables"},{"location":"1-foundation/notes/#multiple-arguments","text":"Each lambda may have only one parameter and thus can only accept one argument. Should an expression require multiple arguments, it must be composed from multiple nested heads. When such composite lambda is applied once, the leftmost/ outmost head is first eliminated, and the next is then applied. Such method of having nested heads is termed currying . Currying An abstraction such as \\lambda x y \\ldotp x y \\lambda x y \\ldotp x y Is shorthand for \\lambda x \\ldotp (\\lambda y \\ldotp x y) \\lambda x \\ldotp (\\lambda y \\ldotp x y) When the first argument x x is applied, x x is bound and the outer lambda is eliminated to become \\lambda y \\ldotp x y \\lambda y \\ldotp x y with some applied x x value. Reduction of a multi-argument lambda Let \\lambda x y \\ldotp x y \\lambda x y \\ldotp x y Be applied to 1 1 and 2 2 respectively. Then \\begin{aligned} (\\lambda x y \\ldotp x y)\\ 1\\ 2 & \\\\ (\\lambda x \\ldotp (\\lambda y \\ldotp x y))\\ 1\\ 2 & \\\\ [x \\coloneq 1] & \\\\ (\\lambda y \\ldotp 1 y)\\ 2 & \\\\ [y \\coloneq 2] & \\\\ 1\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x y \\ldotp x y)\\ 1\\ 2 & \\\\ (\\lambda x \\ldotp (\\lambda y \\ldotp x y))\\ 1\\ 2 & \\\\ [x \\coloneq 1] & \\\\ (\\lambda y \\ldotp 1 y)\\ 2 & \\\\ [y \\coloneq 2] & \\\\ 1\\ 2 & \\\\ \\end{aligned}","title":"Multiple Arguments"},{"location":"1-foundation/notes/#beta-normal-form","text":"A beta normal form (BNF) is when some lambda expression cannot be beta reduced any further - a fully evaluated expression or program.","title":"Beta Normal Form"},{"location":"1-foundation/notes/#combinator","text":"A combinator is a lambda term with no free variables, and only serve to combine given arguments. Valid combinators \\lambda x \\ldotp x \\lambda x \\ldotp x x x is the only variable and is bound. \\lambda x y \\ldotp x \\lambda x y \\ldotp x \\lambda x y z \\ldotp x z (y z) \\lambda x y z \\ldotp x z (y z) Not combinators \\lambda y \\ldotp x \\lambda y \\ldotp x x x is a free variable. \\lambda x \\ldotp x z \\lambda x \\ldotp x z z z is a free variable.","title":"Combinator"},{"location":"1-foundation/notes/#divergence","text":"Some lambda terms do not reduce to a beta normal form because they diverge . Divergence refers to the evaluation process never terminates. Omega lambda term (diverging) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) x x in first lambda's head becomes second lambda. ([x \\coloneq (\\lambda x \\ldotp x x)]) x x ([x \\coloneq (\\lambda x \\ldotp x x)]) x x (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) Substitution of (\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x) for x x causes the original lambda to reappear and thus evaluation cannot terminate.","title":"Divergence"},{"location":"2-haskell-basics/notes/","text":"Haskell Basics \u00b6 Prelude \u00b6 The Prelude is a collection of standard library functions and typeclasses. The Glasgow Haskell Compiler (GHC) has a default Prelude , but one is also able to supply a custom Prelude if necessary. Type Signatures \u00b6 The double colon operator :: denotes that some identifier \" has the type \". That is, id :: TypeName denotes that some identifier id has the type TypeName . Expressions \u00b6 Haskell expressions may be: Values; Combination of values (e.g. arithmetic expressions); and/or Functions applied to values. Declarations \u00b6 Haskell declarations are top-level bindings which assign names to expressions, allowing programmers to refer to such expressions by names. Normal Form \u00b6 Expressions are in normal form if no further reduction steps may be performed (i.e. in irreducible form ). Normal form The expression 1 + 1 is not in normal form since it can be reduced to 2 , which is in normal form. This is done by applying the addition operator ( + ) :: Int -> Int -> Int to two arguments, two 1 s. Redexes Reducible expressions are also called redexes . Functions \u00b6 Since Haskell functions follow those of lambda calculus, each function takes only one argument. With currying \u2014 by applying a series of nested functions with each taking one argument, the innermost expression can obtain the values of multiple arguments. Functions allow programmers to name arguments and the purposes of expressions. This facilitates code reuse and documentation. Function Definition \u00b6 A function definition consists of: Name of function; Formal parameters; Assignment operator = ; Body expression. Example function definition In the function definition double x = x * 2 -- [1] [2] [3] [4] [1] is the function's name; [2] is the single parameter's name; [3] is the definition operator expressing equality; [4] is the body expression. Evaluation \u00b6 When some expression is evaluated , its terms are reduced until the simplest irreducible form, i.e. normal form . Haskell uses lazy evalution which avoids evaluation of terms unless it is inevitable. Haskell does not evaluate everything to normal form by default: It evaluates expressions to weak head normal form (WHNF) by default. Weak head normal form For some expression like ( \\ x -> ( 1 , 1 + x )) 1 Haskell only evaluates to the next intermediate form ( 1 , 1 + 1 ) Unless the final result ( 1 , 2 ) must be evaluated. Infix Operators \u00b6 By default, functions in Haskell are in prefix syntax. Operators are functions which can be used in the infix style. Infix operator The arithmetic addition operator ( + ) is an infix operator. It can also be used as a prefix function ( + ) 1 2 Which is identical to 1 + 2 Some functions like div may be used infix by using backticks: 10 ` div ` 2 == div 10 2 Associativity and Precedence \u00b6 Precendence information on operators may be obtained from GHCi with the :info command. GHCi returns: Type information; Infix or prefix; If infix, then its precedence and associativity; : info ( * ) For the multiplication operator ( * ) GHCi returns infixl 7 * infixl means that the operator ( * ) is an infix operator and is left associative. 7 is ( * ) 's precendece level (between 0-9). * is the operator's name, i.e. multiplication. Associativity Left Associativity For some left associative operator like ( * ) , an expression such as 1 * 3 * 5 is equivalent to (1 * 3) * 5 with parentheses denoting evaluation order, from left to right. Right Associativity For some right associative oerator like ( ^ ) , an expression such as 1 ^ 3 ^ 5 is equivalent to 1 ^ (3 ^ 5) , from right to left. Value Declaration \u00b6 In a Haskell source file {filename}.hs , -- file: arith.hs module Arith where addOne x = x + 1 fileName.hs declares a module Arith . Module name is capitalized and named with PascalCase . Function, variable and parameter names use camelCase . Arithmetic Functions \u00b6 Operator Name Usage ( + ) Plus Addition ( - ) Minus Subtraction ( * ) Asterisk Multiplication ( / ) Slash Fractional division div Divide Integral division, round down mod Modulo Modulo division quot Quotient Integral division, round towards zero rem Remainder Remainder after division Negative Numbers \u00b6 Because ( - ) is an operator, negative numbers may need parentheses to disambiguate. Negative Integer 100 + ( - 9 ) Dollar ($) Operator \u00b6 The ( $ ) operator has the signature ( $ ) :: ( a -> b ) -> a -> b f $ a = f a GHCi gives infixr 0 $ upon using the : info command. It is right associative, and of the lowest possible precedence. This operator helps to reduce the number of parentheses: ( 2 ^ ) ( 2 + 2 ) == ( 2 ^ ) $ 2 + 2 The binary arithmetic operators can be partially applied (e.g. (2^) ), and this is called sectioning . Let and Where \u00b6 The let keyword is part of a let binding expression, while the where keyword is part of a where clause declaration. Both let and where allows extracting parts of an expression and giving them names. Where example printHello name = print greeting where greeting = \"Hello \" ++ name ++ \"!\" Let example printHello name = let greeting = \"Hello \" ++ name ++ \"!\" in print greeting","title":"Haskell Basics"},{"location":"2-haskell-basics/notes/#haskell-basics","text":"","title":"Haskell Basics"},{"location":"2-haskell-basics/notes/#prelude","text":"The Prelude is a collection of standard library functions and typeclasses. The Glasgow Haskell Compiler (GHC) has a default Prelude , but one is also able to supply a custom Prelude if necessary.","title":"Prelude"},{"location":"2-haskell-basics/notes/#type-signatures","text":"The double colon operator :: denotes that some identifier \" has the type \". That is, id :: TypeName denotes that some identifier id has the type TypeName .","title":"Type Signatures"},{"location":"2-haskell-basics/notes/#expressions","text":"Haskell expressions may be: Values; Combination of values (e.g. arithmetic expressions); and/or Functions applied to values.","title":"Expressions"},{"location":"2-haskell-basics/notes/#declarations","text":"Haskell declarations are top-level bindings which assign names to expressions, allowing programmers to refer to such expressions by names.","title":"Declarations"},{"location":"2-haskell-basics/notes/#normal-form","text":"Expressions are in normal form if no further reduction steps may be performed (i.e. in irreducible form ). Normal form The expression 1 + 1 is not in normal form since it can be reduced to 2 , which is in normal form. This is done by applying the addition operator ( + ) :: Int -> Int -> Int to two arguments, two 1 s. Redexes Reducible expressions are also called redexes .","title":"Normal Form"},{"location":"2-haskell-basics/notes/#functions","text":"Since Haskell functions follow those of lambda calculus, each function takes only one argument. With currying \u2014 by applying a series of nested functions with each taking one argument, the innermost expression can obtain the values of multiple arguments. Functions allow programmers to name arguments and the purposes of expressions. This facilitates code reuse and documentation.","title":"Functions"},{"location":"2-haskell-basics/notes/#function-definition","text":"A function definition consists of: Name of function; Formal parameters; Assignment operator = ; Body expression. Example function definition In the function definition double x = x * 2 -- [1] [2] [3] [4] [1] is the function's name; [2] is the single parameter's name; [3] is the definition operator expressing equality; [4] is the body expression.","title":"Function Definition"},{"location":"2-haskell-basics/notes/#evaluation","text":"When some expression is evaluated , its terms are reduced until the simplest irreducible form, i.e. normal form . Haskell uses lazy evalution which avoids evaluation of terms unless it is inevitable. Haskell does not evaluate everything to normal form by default: It evaluates expressions to weak head normal form (WHNF) by default. Weak head normal form For some expression like ( \\ x -> ( 1 , 1 + x )) 1 Haskell only evaluates to the next intermediate form ( 1 , 1 + 1 ) Unless the final result ( 1 , 2 ) must be evaluated.","title":"Evaluation"},{"location":"2-haskell-basics/notes/#infix-operators","text":"By default, functions in Haskell are in prefix syntax. Operators are functions which can be used in the infix style. Infix operator The arithmetic addition operator ( + ) is an infix operator. It can also be used as a prefix function ( + ) 1 2 Which is identical to 1 + 2 Some functions like div may be used infix by using backticks: 10 ` div ` 2 == div 10 2","title":"Infix Operators"},{"location":"2-haskell-basics/notes/#associativity-and-precedence","text":"Precendence information on operators may be obtained from GHCi with the :info command. GHCi returns: Type information; Infix or prefix; If infix, then its precedence and associativity; : info ( * ) For the multiplication operator ( * ) GHCi returns infixl 7 * infixl means that the operator ( * ) is an infix operator and is left associative. 7 is ( * ) 's precendece level (between 0-9). * is the operator's name, i.e. multiplication. Associativity Left Associativity For some left associative operator like ( * ) , an expression such as 1 * 3 * 5 is equivalent to (1 * 3) * 5 with parentheses denoting evaluation order, from left to right. Right Associativity For some right associative oerator like ( ^ ) , an expression such as 1 ^ 3 ^ 5 is equivalent to 1 ^ (3 ^ 5) , from right to left.","title":"Associativity and Precedence"},{"location":"2-haskell-basics/notes/#value-declaration","text":"In a Haskell source file {filename}.hs , -- file: arith.hs module Arith where addOne x = x + 1 fileName.hs declares a module Arith . Module name is capitalized and named with PascalCase . Function, variable and parameter names use camelCase .","title":"Value Declaration"},{"location":"2-haskell-basics/notes/#arithmetic-functions","text":"Operator Name Usage ( + ) Plus Addition ( - ) Minus Subtraction ( * ) Asterisk Multiplication ( / ) Slash Fractional division div Divide Integral division, round down mod Modulo Modulo division quot Quotient Integral division, round towards zero rem Remainder Remainder after division","title":"Arithmetic Functions"},{"location":"2-haskell-basics/notes/#negative-numbers","text":"Because ( - ) is an operator, negative numbers may need parentheses to disambiguate. Negative Integer 100 + ( - 9 )","title":"Negative Numbers"},{"location":"2-haskell-basics/notes/#dollar-operator","text":"The ( $ ) operator has the signature ( $ ) :: ( a -> b ) -> a -> b f $ a = f a GHCi gives infixr 0 $ upon using the : info command. It is right associative, and of the lowest possible precedence. This operator helps to reduce the number of parentheses: ( 2 ^ ) ( 2 + 2 ) == ( 2 ^ ) $ 2 + 2 The binary arithmetic operators can be partially applied (e.g. (2^) ), and this is called sectioning .","title":"Dollar ($) Operator"},{"location":"2-haskell-basics/notes/#let-and-where","text":"The let keyword is part of a let binding expression, while the where keyword is part of a where clause declaration. Both let and where allows extracting parts of an expression and giving them names. Where example printHello name = print greeting where greeting = \"Hello \" ++ name ++ \"!\" Let example printHello name = let greeting = \"Hello \" ++ name ++ \"!\" in print greeting","title":"Let and Where"}]}