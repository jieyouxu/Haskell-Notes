{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Haskell Notes \u00b6 Some notes on Haskell based on Haskell Programming from First Principles .","title":"Haskell Notes"},{"location":"#haskell-notes","text":"Some notes on Haskell based on Haskell Programming from First Principles .","title":"Haskell Notes"},{"location":"1-foundation/notes/","text":"Foundations \u00b6 A calculus is a method of calculating or reasoning . Lambda calculus formalizes effective computability . Functional Programming \u00b6 Functional programming (FP) is a programming paradigm relying on functions modeled on mathematical functions . Programs in FP are composed from expressions , which can be: Values ; Variables ; Functions . Functions are expressions which are applied to an argument / input , which can be reduced or evaluated . Functions are first-class in Haskell, such that they can be used as: Values ; Passed as arguments / inputs to other functions. Purity in FP can mean referential transparency : Given a function f f , if it is given the same input x x , it will always return the same output y y , like a mathematical function. Abstraction allows writing shorter code by extracting common/repeated constructs into more reusable, generic code. High levels of abstraction allows programmers to compose programs from separate functions. Functions \u00b6 A function is the relation between a set of possible inputs and a set of possible outputs . Function application maps input(s) to an output. Example Given some function f f , with the input set ( domain ) \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} and the output set ( codomain ) \\{ A, B, C \\} \\{ A, B, C \\} , with f f defined as \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} Then f f is referentially transparent \u2014 for instance, when f f receives input 1 1 it always outputs A A . This ensures that the function is in fact predictable . Note For OOP languages like Java, objects often constitute of shared mutable state. This can make testing and debugging very difficult because for some input, a method on an object does not necessarily return the same output. The previous example only defined a mapping, but not necessarily a relationship between its input and output. Example Given some function f f , let it be defined as f(x) = \\underbrace{x + 1}_{\\text{function body}} f(x) = \\underbrace{x + 1}_{\\text{function body}} The function f f takes a single named argument x x . f f describes the relationship between the input x x and output (which is described in the function body ). Upon applying the function f f , we substitute its argument x x for a concrete value, for instance 1 1 . Then f(1) = 1 + 1 = 2 f(1) = 1 + 1 = 2 . This establishes a mapping f(1) \\mapsto 2 f(1) \\mapsto 2 .","title":"Foundation"},{"location":"1-foundation/notes/#foundations","text":"A calculus is a method of calculating or reasoning . Lambda calculus formalizes effective computability .","title":"Foundations"},{"location":"1-foundation/notes/#functional-programming","text":"Functional programming (FP) is a programming paradigm relying on functions modeled on mathematical functions . Programs in FP are composed from expressions , which can be: Values ; Variables ; Functions . Functions are expressions which are applied to an argument / input , which can be reduced or evaluated . Functions are first-class in Haskell, such that they can be used as: Values ; Passed as arguments / inputs to other functions. Purity in FP can mean referential transparency : Given a function f f , if it is given the same input x x , it will always return the same output y y , like a mathematical function. Abstraction allows writing shorter code by extracting common/repeated constructs into more reusable, generic code. High levels of abstraction allows programmers to compose programs from separate functions.","title":"Functional Programming"},{"location":"1-foundation/notes/#functions","text":"A function is the relation between a set of possible inputs and a set of possible outputs . Function application maps input(s) to an output. Example Given some function f f , with the input set ( domain ) \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} and the output set ( codomain ) \\{ A, B, C \\} \\{ A, B, C \\} , with f f defined as \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} Then f f is referentially transparent \u2014 for instance, when f f receives input 1 1 it always outputs A A . This ensures that the function is in fact predictable . Note For OOP languages like Java, objects often constitute of shared mutable state. This can make testing and debugging very difficult because for some input, a method on an object does not necessarily return the same output. The previous example only defined a mapping, but not necessarily a relationship between its input and output. Example Given some function f f , let it be defined as f(x) = \\underbrace{x + 1}_{\\text{function body}} f(x) = \\underbrace{x + 1}_{\\text{function body}} The function f f takes a single named argument x x . f f describes the relationship between the input x x and output (which is described in the function body ). Upon applying the function f f , we substitute its argument x x for a concrete value, for instance 1 1 . Then f(1) = 1 + 1 = 2 f(1) = 1 + 1 = 2 . This establishes a mapping f(1) \\mapsto 2 f(1) \\mapsto 2 .","title":"Functions"}]}