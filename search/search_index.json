{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Haskell Notes \u00b6 Some notes on Haskell based on Haskell Programming from First Principles .","title":"Haskell Notes"},{"location":"#haskell-notes","text":"Some notes on Haskell based on Haskell Programming from First Principles .","title":"Haskell Notes"},{"location":"1-foundation/notes/","text":"Foundations \u00b6 A calculus is a method of calculating or reasoning . Lambda calculus formalizes effective computability . Functional Programming \u00b6 Functional programming (FP) is a programming paradigm relying on functions modeled on mathematical functions . Programs in FP are composed from expressions , which can be: Values ; Variables ; Functions . Functions are expressions which are applied to an argument / input , which can be reduced or evaluated . Functions are first-class in Haskell, such that they can be used as: Values ; Passed as arguments / inputs to other functions. Purity in FP can mean referential transparency : Given a function f f , if it is given the same input x x , it will always return the same output y y , like a mathematical function. Abstraction allows writing shorter code by extracting common/repeated constructs into more reusable, generic code. High levels of abstraction allows programmers to compose programs from separate functions. Functions \u00b6 A function is the relation between a set of possible inputs and a set of possible outputs . Function application maps input(s) to an output. Example Given some function f f , with the input set ( domain ) \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} and the output set ( codomain ) \\{ A, B, C \\} \\{ A, B, C \\} , with f f defined as \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} Then f f is referentially transparent \u2014 for instance, when f f receives input 1 1 it always outputs A A . This ensures that the function is in fact predictable . Note For OOP languages like Java, objects often constitute of shared mutable state. This can make testing and debugging very difficult because for some input, a method on an object does not necessarily return the same output. The previous example only defined a mapping, but not necessarily a relationship between its input and output. Example Given some function f f , let it be defined as f(x) = \\underbrace{x + 1}_{\\text{function body}} f(x) = \\underbrace{x + 1}_{\\text{function body}} The function f f takes a single named argument x x . f f describes the relationship between the input x x and output (which is described in the function body ). Upon applying the function f f , we substitute its argument x x for a concrete value, for instance 1 1 . Then f(1) = 1 + 1 = 2 f(1) = 1 + 1 = 2 . This establishes a mapping f(1) \\mapsto 2 f(1) \\mapsto 2 . Structure of Lambda Calculus \u00b6 The lambda calculus comprises three lambda terms : Expressions Variables Abstractions An expression is either one of the three lambda terms or a combination of them (hence an inductive definition). The simplest expression is a single variable, which has no meaning or value and are simply placeholder names for inputs. An abstraction is a function ; it has A head (a lambda ) A body And is applied to an argument , which is an input value. Abstraction An abstraction is built from a head and a body . The head of a function is a \\lambda \\lambda followed by a variable name. The body is another expression . Simple abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x The variable x x named in the head is the abstraction's parameter which binds all occurrences of x x in the body. When the abstraction is applied with an input value v v given to x x , all occurrences of x x in the body takes on that input value v v . In the abstraction, the \\lambda x \\lambda x part is the head , the x x in the head is the single parameter , and the x x to the right of the \\ldotp \\ldotp is the body. Note that the x x in the body is bound by the parameter of the same name. The dot \\ldotp \\ldotp acts as a separator. Anonymous function The previous example's lambda abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x does not have a name, hence it is anonymous . Hence it cannot be called by name. It is called an abstraction since it is a generalization of a concrete problem, and names given to it allows abstraction \u2014 abstracting away from tiny details to simplify the cognitive burden and facilitates code reuse. By using named variables, we can reuse the abstraction for potentially many instances of similar problems. Alpha Equivalence \u00b6 For some lambda abstraction such as \\lambda x \\ldotp x \\lambda x \\ldotp x The named variable x x has no semantic meaning apart from being a placeholder for input values. Hence, it might as well be a a or b b or c c , etc. This means that the lambda terms \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta Have alpba equivalence \u2014 they are the same function. Beta Reduction \u00b6 Upon applying a function to an argument, all occurrences of the bound variable within the body (that is the parameter) are substituted with the input expression. The head can safely be eliminated as it only serves the purpose of binding a name to the parameter. Example For the abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x If the abstraction is applied to 2 2 , then: Substitute 2 2 for every occurrence of x x in the body. Eliminate the head. That is, \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} Identity function The previous example function \\lambda x \\ldotp x \\lambda x \\ldotp x is the identity function since it simply returns whatever input expression was given to it. This is like f(x) = x f(x) = x . To denote precedence, let parentheses () () be used to group the body expression of an abstraction. Parentheses showing precedence (\\lambda x \\ldotp x + 1) (\\lambda x \\ldotp x + 1) Here the body expression is x + 1 x + 1 . A lambda abstraction can also be applied to another lambda abstraction. Square brackets [] [] shall be used to denote substitution. Square brackets showing substitution \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} Associativity of application Applications in lambda calculus are left associative from the right to the left. Left associativity of lambda application (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z This expression may be reduced as \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned}","title":"Foundation"},{"location":"1-foundation/notes/#foundations","text":"A calculus is a method of calculating or reasoning . Lambda calculus formalizes effective computability .","title":"Foundations"},{"location":"1-foundation/notes/#functional-programming","text":"Functional programming (FP) is a programming paradigm relying on functions modeled on mathematical functions . Programs in FP are composed from expressions , which can be: Values ; Variables ; Functions . Functions are expressions which are applied to an argument / input , which can be reduced or evaluated . Functions are first-class in Haskell, such that they can be used as: Values ; Passed as arguments / inputs to other functions. Purity in FP can mean referential transparency : Given a function f f , if it is given the same input x x , it will always return the same output y y , like a mathematical function. Abstraction allows writing shorter code by extracting common/repeated constructs into more reusable, generic code. High levels of abstraction allows programmers to compose programs from separate functions.","title":"Functional Programming"},{"location":"1-foundation/notes/#functions","text":"A function is the relation between a set of possible inputs and a set of possible outputs . Function application maps input(s) to an output. Example Given some function f f , with the input set ( domain ) \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} and the output set ( codomain ) \\{ A, B, C \\} \\{ A, B, C \\} , with f f defined as \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} Then f f is referentially transparent \u2014 for instance, when f f receives input 1 1 it always outputs A A . This ensures that the function is in fact predictable . Note For OOP languages like Java, objects often constitute of shared mutable state. This can make testing and debugging very difficult because for some input, a method on an object does not necessarily return the same output. The previous example only defined a mapping, but not necessarily a relationship between its input and output. Example Given some function f f , let it be defined as f(x) = \\underbrace{x + 1}_{\\text{function body}} f(x) = \\underbrace{x + 1}_{\\text{function body}} The function f f takes a single named argument x x . f f describes the relationship between the input x x and output (which is described in the function body ). Upon applying the function f f , we substitute its argument x x for a concrete value, for instance 1 1 . Then f(1) = 1 + 1 = 2 f(1) = 1 + 1 = 2 . This establishes a mapping f(1) \\mapsto 2 f(1) \\mapsto 2 .","title":"Functions"},{"location":"1-foundation/notes/#structure-of-lambda-calculus","text":"The lambda calculus comprises three lambda terms : Expressions Variables Abstractions An expression is either one of the three lambda terms or a combination of them (hence an inductive definition). The simplest expression is a single variable, which has no meaning or value and are simply placeholder names for inputs. An abstraction is a function ; it has A head (a lambda ) A body And is applied to an argument , which is an input value. Abstraction An abstraction is built from a head and a body . The head of a function is a \\lambda \\lambda followed by a variable name. The body is another expression . Simple abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x The variable x x named in the head is the abstraction's parameter which binds all occurrences of x x in the body. When the abstraction is applied with an input value v v given to x x , all occurrences of x x in the body takes on that input value v v . In the abstraction, the \\lambda x \\lambda x part is the head , the x x in the head is the single parameter , and the x x to the right of the \\ldotp \\ldotp is the body. Note that the x x in the body is bound by the parameter of the same name. The dot \\ldotp \\ldotp acts as a separator. Anonymous function The previous example's lambda abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x does not have a name, hence it is anonymous . Hence it cannot be called by name. It is called an abstraction since it is a generalization of a concrete problem, and names given to it allows abstraction \u2014 abstracting away from tiny details to simplify the cognitive burden and facilitates code reuse. By using named variables, we can reuse the abstraction for potentially many instances of similar problems.","title":"Structure of Lambda Calculus"},{"location":"1-foundation/notes/#alpha-equivalence","text":"For some lambda abstraction such as \\lambda x \\ldotp x \\lambda x \\ldotp x The named variable x x has no semantic meaning apart from being a placeholder for input values. Hence, it might as well be a a or b b or c c , etc. This means that the lambda terms \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta Have alpba equivalence \u2014 they are the same function.","title":"Alpha Equivalence"},{"location":"1-foundation/notes/#beta-reduction","text":"Upon applying a function to an argument, all occurrences of the bound variable within the body (that is the parameter) are substituted with the input expression. The head can safely be eliminated as it only serves the purpose of binding a name to the parameter. Example For the abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x If the abstraction is applied to 2 2 , then: Substitute 2 2 for every occurrence of x x in the body. Eliminate the head. That is, \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} Identity function The previous example function \\lambda x \\ldotp x \\lambda x \\ldotp x is the identity function since it simply returns whatever input expression was given to it. This is like f(x) = x f(x) = x . To denote precedence, let parentheses () () be used to group the body expression of an abstraction. Parentheses showing precedence (\\lambda x \\ldotp x + 1) (\\lambda x \\ldotp x + 1) Here the body expression is x + 1 x + 1 . A lambda abstraction can also be applied to another lambda abstraction. Square brackets [] [] shall be used to denote substitution. Square brackets showing substitution \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} Associativity of application Applications in lambda calculus are left associative from the right to the left. Left associativity of lambda application (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z This expression may be reduced as \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned}","title":"Beta Reduction"}]}