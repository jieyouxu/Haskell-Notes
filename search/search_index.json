{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Haskell Notes \u00b6 Some notes on Haskell based on Haskell Programming from First Principles .","title":"Home"},{"location":"#haskell-notes","text":"Some notes on Haskell based on Haskell Programming from First Principles .","title":"Haskell Notes"},{"location":"1-foundation/notes/","text":"Foundations \u00b6 A calculus is a method of calculating or reasoning . Lambda calculus formalizes effective computability . Functional Programming \u00b6 Functional programming (FP) is a programming paradigm relying on functions modeled on mathematical functions . Programs in FP are composed from expressions , which can be: Values ; Variables ; Functions . Functions are expressions which are applied to an argument / input , which can be reduced or evaluated . Functions are first-class in Haskell, such that they can be used as: Values ; Passed as arguments / inputs to other functions. Purity in FP can mean referential transparency : Given a function f f , if it is given the same input x x , it will always return the same output y y , like a mathematical function. Abstraction allows writing shorter code by extracting common/repeated constructs into more reusable, generic code. High levels of abstraction allows programmers to compose programs from separate functions. Functions \u00b6 A function is the relation between a set of possible inputs and a set of possible outputs . Function application maps input(s) to an output. Example Given some function f f , with the input set ( domain ) \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} and the output set ( codomain ) \\{ A, B, C \\} \\{ A, B, C \\} , with f f defined as \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} Then f f is referentially transparent \u2014 for instance, when f f receives input 1 1 it always outputs A A . This ensures that the function is in fact predictable . Note For OOP languages like Java, objects often constitute of shared mutable state. This can make testing and debugging very difficult because for some input, a method on an object does not necessarily return the same output. The previous example only defined a mapping, but not necessarily a relationship between its input and output. Example Given some function f f , let it be defined as f(x) = \\underbrace{x + 1}_{\\text{function body}} f(x) = \\underbrace{x + 1}_{\\text{function body}} The function f f takes a single named argument x x . f f describes the relationship between the input x x and output (which is described in the function body ). Upon applying the function f f , we substitute its argument x x for a concrete value, for instance 1 1 . Then f(1) = 1 + 1 = 2 f(1) = 1 + 1 = 2 . This establishes a mapping f(1) \\mapsto 2 f(1) \\mapsto 2 . Structure of Lambda Calculus \u00b6 The lambda calculus comprises three lambda terms : Expressions Variables Abstractions An expression is either one of the three lambda terms or a combination of them (hence an inductive definition). The simplest expression is a single variable, which has no meaning or value and are simply placeholder names for inputs. An abstraction is a function ; it has A head (a lambda ) A body And is applied to an argument , which is an input value. Hereafter a lambda abstraction will be referred to as a \" lambda \" or an \" abstraction \" for brevity. Abstraction An abstraction is built from a head and a body . The head of a function is a \\lambda \\lambda followed by a variable name. The body is another expression . Simple abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x The variable x x named in the head is the abstraction's parameter which binds all occurrences of x x in the body. When the abstraction is applied with an input value v v given to x x , all occurrences of x x in the body takes on that input value v v . In the abstraction, the \\lambda x \\lambda x part is the head , the x x in the head is the single parameter , and the x x to the right of the \\ldotp \\ldotp is the body. Note that the x x in the body is bound by the parameter of the same name. The dot \\ldotp \\ldotp acts as a separator. Anonymous function The previous example's lambda abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x does not have a name, hence it is anonymous . Hence it cannot be called by name. It is called an abstraction since it is a generalization of a concrete problem, and names given to it allows abstraction \u2014 abstracting away from tiny details to simplify the cognitive burden and facilitates code reuse. By using named variables, we can reuse the abstraction for potentially many instances of similar problems. Alpha Equivalence \u00b6 For some lambda abstraction such as \\lambda x \\ldotp x \\lambda x \\ldotp x The named variable x x has no semantic meaning apart from being a placeholder for input values. Hence, it might as well be a a or b b or c c , etc. This means that the lambda terms \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta Have alpba equivalence \u2014 they are the same function. Beta Reduction \u00b6 Upon applying a function to an argument, all occurrences of the bound variable within the body (that is the parameter) are substituted with the input expression. The head can safely be eliminated as it only serves the purpose of binding a name to the parameter. Example For the abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x If the abstraction is applied to 2 2 , then: Substitute 2 2 for every occurrence of x x in the body. Eliminate the head. That is, \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} Identity function The previous example function \\lambda x \\ldotp x \\lambda x \\ldotp x is the identity function since it simply returns whatever input expression was given to it. This is like f(x) = x f(x) = x . To denote precedence, let parentheses () () be used to group the body expression of an abstraction. Parentheses showing precedence (\\lambda x \\ldotp x + 1) (\\lambda x \\ldotp x + 1) Here the body expression is x + 1 x + 1 . A lambda abstraction can also be applied to another lambda abstraction. Square brackets [] [] shall be used to denote substitution. Square brackets showing substitution \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} Associativity of application Applications in lambda calculus are left associative from the right to the left. Left associativity of lambda application (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z This expression may be reduced as \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned} Free Variables \u00b6 The head of an lambda abstraction provides information on which named variable is bounded to be in scope when the function is applied. Those variables in the expression body which are not named in the head are free variables . Free variable In the lambda abstraction \\lambda x \\ldotp x y \\lambda x \\ldotp x y y y is a free variable as it is not named in the head. It cannot be reduced when the function is applied to an argument. Applying lambda abstraction to a variable The lambda abstraction \\lambda x \\ldotp x y \\lambda x \\ldotp x y Can be applied to some variable z z (\\lambda x \\ldotp x y) z (\\lambda x \\ldotp x y) z . The lambda can be applied to the argument z z . (\\lambda [x \\coloneq z] \\ldotp x y) (\\lambda [x \\coloneq z] \\ldotp x y) . x x is the bound variable and its instances shall be replaced by z z , with the head being eliminated. z y z y . Head was eliminated and no more heads are left, and since z z and y y are free variables no further reductions may be applied. Multiple Arguments \u00b6 Each lambda may have only one parameter and thus can only accept one argument. Should an expression require multiple arguments, it must be composed from multiple nested heads. When such composite lambda is applied once, the leftmost/ outmost head is first eliminated, and the next is then applied. Such method of having nested heads is termed currying . Currying An abstraction such as \\lambda x y \\ldotp x y \\lambda x y \\ldotp x y Is shorthand for \\lambda x \\ldotp (\\lambda y \\ldotp x y) \\lambda x \\ldotp (\\lambda y \\ldotp x y) When the first argument x x is applied, x x is bound and the outer lambda is eliminated to become \\lambda y \\ldotp x y \\lambda y \\ldotp x y with some applied x x value. Reduction of a multi-argument lambda Let \\lambda x y \\ldotp x y \\lambda x y \\ldotp x y Be applied to 1 1 and 2 2 respectively. Then \\begin{aligned} (\\lambda x y \\ldotp x y)\\ 1\\ 2 & \\\\ (\\lambda x \\ldotp (\\lambda y \\ldotp x y))\\ 1\\ 2 & \\\\ [x \\coloneq 1] & \\\\ (\\lambda y \\ldotp 1 y)\\ 2 & \\\\ [y \\coloneq 2] & \\\\ 1\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x y \\ldotp x y)\\ 1\\ 2 & \\\\ (\\lambda x \\ldotp (\\lambda y \\ldotp x y))\\ 1\\ 2 & \\\\ [x \\coloneq 1] & \\\\ (\\lambda y \\ldotp 1 y)\\ 2 & \\\\ [y \\coloneq 2] & \\\\ 1\\ 2 & \\\\ \\end{aligned} Beta Normal Form \u00b6 A beta normal form (BNF) is when some lambda expression cannot be beta reduced any further - a fully evaluated expression or program. Combinator \u00b6 A combinator is a lambda term with no free variables, and only serve to combine given arguments. Valid combinators \\lambda x \\ldotp x \\lambda x \\ldotp x x x is the only variable and is bound. \\lambda x y \\ldotp x \\lambda x y \\ldotp x \\lambda x y z \\ldotp x z (y z) \\lambda x y z \\ldotp x z (y z) Not combinators \\lambda y \\ldotp x \\lambda y \\ldotp x x x is a free variable. \\lambda x \\ldotp x z \\lambda x \\ldotp x z z z is a free variable. Divergence \u00b6 Some lambda terms do not reduce to a beta normal form because they diverge . Divergence refers to the evaluation process never terminates. Omega lambda term (diverging) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) x x in first lambda's head becomes second lambda. ([x \\coloneq (\\lambda x \\ldotp x x)]) x x ([x \\coloneq (\\lambda x \\ldotp x x)]) x x (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) Substitution of (\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x) for x x causes the original lambda to reappear and thus evaluation cannot terminate.","title":"Foundation"},{"location":"1-foundation/notes/#foundations","text":"A calculus is a method of calculating or reasoning . Lambda calculus formalizes effective computability .","title":"Foundations"},{"location":"1-foundation/notes/#functional-programming","text":"Functional programming (FP) is a programming paradigm relying on functions modeled on mathematical functions . Programs in FP are composed from expressions , which can be: Values ; Variables ; Functions . Functions are expressions which are applied to an argument / input , which can be reduced or evaluated . Functions are first-class in Haskell, such that they can be used as: Values ; Passed as arguments / inputs to other functions. Purity in FP can mean referential transparency : Given a function f f , if it is given the same input x x , it will always return the same output y y , like a mathematical function. Abstraction allows writing shorter code by extracting common/repeated constructs into more reusable, generic code. High levels of abstraction allows programmers to compose programs from separate functions.","title":"Functional Programming"},{"location":"1-foundation/notes/#functions","text":"A function is the relation between a set of possible inputs and a set of possible outputs . Function application maps input(s) to an output. Example Given some function f f , with the input set ( domain ) \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} and the output set ( codomain ) \\{ A, B, C \\} \\{ A, B, C \\} , with f f defined as \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} \\begin{aligned} f(1) &= A \\\\ f(2) &= B \\\\ f(3) &= C \\\\ \\end{aligned} Then f f is referentially transparent \u2014 for instance, when f f receives input 1 1 it always outputs A A . This ensures that the function is in fact predictable . Note For OOP languages like Java, objects often constitute of shared mutable state. This can make testing and debugging very difficult because for some input, a method on an object does not necessarily return the same output. The previous example only defined a mapping, but not necessarily a relationship between its input and output. Example Given some function f f , let it be defined as f(x) = \\underbrace{x + 1}_{\\text{function body}} f(x) = \\underbrace{x + 1}_{\\text{function body}} The function f f takes a single named argument x x . f f describes the relationship between the input x x and output (which is described in the function body ). Upon applying the function f f , we substitute its argument x x for a concrete value, for instance 1 1 . Then f(1) = 1 + 1 = 2 f(1) = 1 + 1 = 2 . This establishes a mapping f(1) \\mapsto 2 f(1) \\mapsto 2 .","title":"Functions"},{"location":"1-foundation/notes/#structure-of-lambda-calculus","text":"The lambda calculus comprises three lambda terms : Expressions Variables Abstractions An expression is either one of the three lambda terms or a combination of them (hence an inductive definition). The simplest expression is a single variable, which has no meaning or value and are simply placeholder names for inputs. An abstraction is a function ; it has A head (a lambda ) A body And is applied to an argument , which is an input value. Hereafter a lambda abstraction will be referred to as a \" lambda \" or an \" abstraction \" for brevity. Abstraction An abstraction is built from a head and a body . The head of a function is a \\lambda \\lambda followed by a variable name. The body is another expression . Simple abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x The variable x x named in the head is the abstraction's parameter which binds all occurrences of x x in the body. When the abstraction is applied with an input value v v given to x x , all occurrences of x x in the body takes on that input value v v . In the abstraction, the \\lambda x \\lambda x part is the head , the x x in the head is the single parameter , and the x x to the right of the \\ldotp \\ldotp is the body. Note that the x x in the body is bound by the parameter of the same name. The dot \\ldotp \\ldotp acts as a separator. Anonymous function The previous example's lambda abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x does not have a name, hence it is anonymous . Hence it cannot be called by name. It is called an abstraction since it is a generalization of a concrete problem, and names given to it allows abstraction \u2014 abstracting away from tiny details to simplify the cognitive burden and facilitates code reuse. By using named variables, we can reuse the abstraction for potentially many instances of similar problems.","title":"Structure of Lambda Calculus"},{"location":"1-foundation/notes/#alpha-equivalence","text":"For some lambda abstraction such as \\lambda x \\ldotp x \\lambda x \\ldotp x The named variable x x has no semantic meaning apart from being a placeholder for input values. Hence, it might as well be a a or b b or c c , etc. This means that the lambda terms \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta \\lambda x \\ldotp x \\Leftrightarrow \\lambda y \\ldotp y \\Leftrightarrow \\lambda \\beta \\ldotp \\beta Have alpba equivalence \u2014 they are the same function.","title":"Alpha Equivalence"},{"location":"1-foundation/notes/#beta-reduction","text":"Upon applying a function to an argument, all occurrences of the bound variable within the body (that is the parameter) are substituted with the input expression. The head can safely be eliminated as it only serves the purpose of binding a name to the parameter. Example For the abstraction \\lambda x \\ldotp x \\lambda x \\ldotp x If the abstraction is applied to 2 2 , then: Substitute 2 2 for every occurrence of x x in the body. Eliminate the head. That is, \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x \\ldotp x)\\ 2 & \\\\ 2 & \\\\ \\end{aligned} Identity function The previous example function \\lambda x \\ldotp x \\lambda x \\ldotp x is the identity function since it simply returns whatever input expression was given to it. This is like f(x) = x f(x) = x . To denote precedence, let parentheses () () be used to group the body expression of an abstraction. Parentheses showing precedence (\\lambda x \\ldotp x + 1) (\\lambda x \\ldotp x + 1) Here the body expression is x + 1 x + 1 . A lambda abstraction can also be applied to another lambda abstraction. Square brackets [] [] shall be used to denote substitution. Square brackets showing substitution \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) & \\\\ \\end{aligned} Associativity of application Applications in lambda calculus are left associative from the right to the left. Left associativity of lambda application (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z \\Leftrightarrow ((\\lambda x \\ldotp x)(\\lambda y \\ldotp y))z This expression may be reduced as \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned} \\newcommand{\\coloneq}{\\mathrel{\\vcenter{:}}=} \\begin{aligned} (\\lambda x \\ldotp x)(\\lambda y \\ldotp y) z & \\\\ [x \\coloneq (\\lambda y \\ldotp y)] & \\\\ (\\lambda y \\ldotp y) z \\\\ [y \\coloneq z] \\\\ z \\end{aligned}","title":"Beta Reduction"},{"location":"1-foundation/notes/#free-variables","text":"The head of an lambda abstraction provides information on which named variable is bounded to be in scope when the function is applied. Those variables in the expression body which are not named in the head are free variables . Free variable In the lambda abstraction \\lambda x \\ldotp x y \\lambda x \\ldotp x y y y is a free variable as it is not named in the head. It cannot be reduced when the function is applied to an argument. Applying lambda abstraction to a variable The lambda abstraction \\lambda x \\ldotp x y \\lambda x \\ldotp x y Can be applied to some variable z z (\\lambda x \\ldotp x y) z (\\lambda x \\ldotp x y) z . The lambda can be applied to the argument z z . (\\lambda [x \\coloneq z] \\ldotp x y) (\\lambda [x \\coloneq z] \\ldotp x y) . x x is the bound variable and its instances shall be replaced by z z , with the head being eliminated. z y z y . Head was eliminated and no more heads are left, and since z z and y y are free variables no further reductions may be applied.","title":"Free Variables"},{"location":"1-foundation/notes/#multiple-arguments","text":"Each lambda may have only one parameter and thus can only accept one argument. Should an expression require multiple arguments, it must be composed from multiple nested heads. When such composite lambda is applied once, the leftmost/ outmost head is first eliminated, and the next is then applied. Such method of having nested heads is termed currying . Currying An abstraction such as \\lambda x y \\ldotp x y \\lambda x y \\ldotp x y Is shorthand for \\lambda x \\ldotp (\\lambda y \\ldotp x y) \\lambda x \\ldotp (\\lambda y \\ldotp x y) When the first argument x x is applied, x x is bound and the outer lambda is eliminated to become \\lambda y \\ldotp x y \\lambda y \\ldotp x y with some applied x x value. Reduction of a multi-argument lambda Let \\lambda x y \\ldotp x y \\lambda x y \\ldotp x y Be applied to 1 1 and 2 2 respectively. Then \\begin{aligned} (\\lambda x y \\ldotp x y)\\ 1\\ 2 & \\\\ (\\lambda x \\ldotp (\\lambda y \\ldotp x y))\\ 1\\ 2 & \\\\ [x \\coloneq 1] & \\\\ (\\lambda y \\ldotp 1 y)\\ 2 & \\\\ [y \\coloneq 2] & \\\\ 1\\ 2 & \\\\ \\end{aligned} \\begin{aligned} (\\lambda x y \\ldotp x y)\\ 1\\ 2 & \\\\ (\\lambda x \\ldotp (\\lambda y \\ldotp x y))\\ 1\\ 2 & \\\\ [x \\coloneq 1] & \\\\ (\\lambda y \\ldotp 1 y)\\ 2 & \\\\ [y \\coloneq 2] & \\\\ 1\\ 2 & \\\\ \\end{aligned}","title":"Multiple Arguments"},{"location":"1-foundation/notes/#beta-normal-form","text":"A beta normal form (BNF) is when some lambda expression cannot be beta reduced any further - a fully evaluated expression or program.","title":"Beta Normal Form"},{"location":"1-foundation/notes/#combinator","text":"A combinator is a lambda term with no free variables, and only serve to combine given arguments. Valid combinators \\lambda x \\ldotp x \\lambda x \\ldotp x x x is the only variable and is bound. \\lambda x y \\ldotp x \\lambda x y \\ldotp x \\lambda x y z \\ldotp x z (y z) \\lambda x y z \\ldotp x z (y z) Not combinators \\lambda y \\ldotp x \\lambda y \\ldotp x x x is a free variable. \\lambda x \\ldotp x z \\lambda x \\ldotp x z z z is a free variable.","title":"Combinator"},{"location":"1-foundation/notes/#divergence","text":"Some lambda terms do not reduce to a beta normal form because they diverge . Divergence refers to the evaluation process never terminates. Omega lambda term (diverging) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) x x in first lambda's head becomes second lambda. ([x \\coloneq (\\lambda x \\ldotp x x)]) x x ([x \\coloneq (\\lambda x \\ldotp x x)]) x x (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x)(\\lambda x \\ldotp x x) Substitution of (\\lambda x \\ldotp x x) (\\lambda x \\ldotp x x) for x x causes the original lambda to reappear and thus evaluation cannot terminate.","title":"Divergence"},{"location":"2-haskell-basics/notes/","text":"Haskell Basics \u00b6 Prelude \u00b6 The Prelude is a collection of standard library functions and typeclasses. The Glasgow Haskell Compiler (GHC) has a default Prelude , but one is also able to supply a custom Prelude if necessary. Type Signatures \u00b6 The double colon operator :: denotes that some identifier \" has the type \". That is, id :: TypeName denotes that some identifier id has the type TypeName . Expressions \u00b6 Haskell expressions may be: Values; Combination of values (e.g. arithmetic expressions); and/or Functions applied to values. Declarations \u00b6 Haskell declarations are top-level bindings which assign names to expressions, allowing programmers to refer to such expressions by names. Normal Form \u00b6 Expressions are in normal form if no further reduction steps may be performed (i.e. in irreducible form ). Normal form The expression 1 + 1 is not in normal form since it can be reduced to 2 , which is in normal form. This is done by applying the addition operator ( + ) :: Int -> Int -> Int to two arguments, two 1 s. Redexes Reducible expressions are also called redexes . Functions \u00b6 Since Haskell functions follow those of lambda calculus, each function takes only one argument. With currying \u2014 by applying a series of nested functions with each taking one argument, the innermost expression can obtain the values of multiple arguments. Functions allow programmers to name arguments and the purposes of expressions. This facilitates code reuse and documentation. Function Definition \u00b6 A function definition consists of: Name of function; Formal parameters; Assignment operator = ; Body expression. Example function definition In the function definition double x = x * 2 -- [1] [2] [3] [4] [1] is the function's name; [2] is the single parameter's name; [3] is the definition operator expressing equality; [4] is the body expression. Evaluation \u00b6 When some expression is evaluated , its terms are reduced until the simplest irreducible form, i.e. normal form . Haskell uses lazy evalution which avoids evaluation of terms unless it is inevitable. Haskell does not evaluate everything to normal form by default: It evaluates expressions to weak head normal form (WHNF) by default. Weak head normal form For some expression like ( \\ x -> ( 1 , 1 + x )) 1 Haskell only evaluates to the next intermediate form ( 1 , 1 + 1 ) Unless the final result ( 1 , 2 ) must be evaluated. Infix Operators \u00b6 By default, functions in Haskell are in prefix syntax. Operators are functions which can be used in the infix style. Infix operator The arithmetic addition operator ( + ) is an infix operator. It can also be used as a prefix function ( + ) 1 2 Which is identical to 1 + 2 Some functions like div may be used infix by using backticks: 10 ` div ` 2 == div 10 2 Associativity and Precedence \u00b6 Precendence information on operators may be obtained from GHCi with the :info command. GHCi returns: Type information; Infix or prefix; If infix, then its precedence and associativity; : info ( * ) For the multiplication operator ( * ) GHCi returns infixl 7 * infixl means that the operator ( * ) is an infix operator and is left associative. 7 is ( * ) 's precendece level (between 0-9). * is the operator's name, i.e. multiplication. Associativity Left Associativity For some left associative operator like ( * ) , an expression such as 1 * 3 * 5 is equivalent to (1 * 3) * 5 with parentheses denoting evaluation order, from left to right. Right Associativity For some right associative oerator like ( ^ ) , an expression such as 1 ^ 3 ^ 5 is equivalent to 1 ^ (3 ^ 5) , from right to left. Value Declaration \u00b6 In a Haskell source file {filename}.hs , -- file: arith.hs module Arith where addOne x = x + 1 fileName.hs declares a module Arith . Module name is capitalized and named with PascalCase . Function, variable and parameter names use camelCase . Arithmetic Functions \u00b6 Operator Name Usage ( + ) Plus Addition ( - ) Minus Subtraction ( * ) Asterisk Multiplication ( / ) Slash Fractional division div Divide Integral division, round down mod Modulo Modulo division quot Quotient Integral division, round towards zero rem Remainder Remainder after division Negative Numbers \u00b6 Because ( - ) is an operator, negative numbers may need parentheses to disambiguate. Negative Integer 100 + ( - 9 ) Dollar ($) Operator \u00b6 The ( $ ) operator has the signature ( $ ) :: ( a -> b ) -> a -> b f $ a = f a GHCi gives infixr 0 $ upon using the : info command. It is right associative, and of the lowest possible precedence. This operator helps to reduce the number of parentheses: ( 2 ^ ) ( 2 + 2 ) == ( 2 ^ ) $ 2 + 2 The binary arithmetic operators can be partially applied (e.g. (2^) ), and this is called sectioning . Let and Where \u00b6 The let keyword is part of a let binding expression, while the where keyword is part of a where clause declaration. Both let and where allows extracting parts of an expression and giving them names. Where example printHello name = print greeting where greeting = \"Hello \" ++ name ++ \"!\" Let example printHello name = let greeting = \"Hello \" ++ name ++ \"!\" in print greeting","title":"Haskell Basics"},{"location":"2-haskell-basics/notes/#haskell-basics","text":"","title":"Haskell Basics"},{"location":"2-haskell-basics/notes/#prelude","text":"The Prelude is a collection of standard library functions and typeclasses. The Glasgow Haskell Compiler (GHC) has a default Prelude , but one is also able to supply a custom Prelude if necessary.","title":"Prelude"},{"location":"2-haskell-basics/notes/#type-signatures","text":"The double colon operator :: denotes that some identifier \" has the type \". That is, id :: TypeName denotes that some identifier id has the type TypeName .","title":"Type Signatures"},{"location":"2-haskell-basics/notes/#expressions","text":"Haskell expressions may be: Values; Combination of values (e.g. arithmetic expressions); and/or Functions applied to values.","title":"Expressions"},{"location":"2-haskell-basics/notes/#declarations","text":"Haskell declarations are top-level bindings which assign names to expressions, allowing programmers to refer to such expressions by names.","title":"Declarations"},{"location":"2-haskell-basics/notes/#normal-form","text":"Expressions are in normal form if no further reduction steps may be performed (i.e. in irreducible form ). Normal form The expression 1 + 1 is not in normal form since it can be reduced to 2 , which is in normal form. This is done by applying the addition operator ( + ) :: Int -> Int -> Int to two arguments, two 1 s. Redexes Reducible expressions are also called redexes .","title":"Normal Form"},{"location":"2-haskell-basics/notes/#functions","text":"Since Haskell functions follow those of lambda calculus, each function takes only one argument. With currying \u2014 by applying a series of nested functions with each taking one argument, the innermost expression can obtain the values of multiple arguments. Functions allow programmers to name arguments and the purposes of expressions. This facilitates code reuse and documentation.","title":"Functions"},{"location":"2-haskell-basics/notes/#function-definition","text":"A function definition consists of: Name of function; Formal parameters; Assignment operator = ; Body expression. Example function definition In the function definition double x = x * 2 -- [1] [2] [3] [4] [1] is the function's name; [2] is the single parameter's name; [3] is the definition operator expressing equality; [4] is the body expression.","title":"Function Definition"},{"location":"2-haskell-basics/notes/#evaluation","text":"When some expression is evaluated , its terms are reduced until the simplest irreducible form, i.e. normal form . Haskell uses lazy evalution which avoids evaluation of terms unless it is inevitable. Haskell does not evaluate everything to normal form by default: It evaluates expressions to weak head normal form (WHNF) by default. Weak head normal form For some expression like ( \\ x -> ( 1 , 1 + x )) 1 Haskell only evaluates to the next intermediate form ( 1 , 1 + 1 ) Unless the final result ( 1 , 2 ) must be evaluated.","title":"Evaluation"},{"location":"2-haskell-basics/notes/#infix-operators","text":"By default, functions in Haskell are in prefix syntax. Operators are functions which can be used in the infix style. Infix operator The arithmetic addition operator ( + ) is an infix operator. It can also be used as a prefix function ( + ) 1 2 Which is identical to 1 + 2 Some functions like div may be used infix by using backticks: 10 ` div ` 2 == div 10 2","title":"Infix Operators"},{"location":"2-haskell-basics/notes/#associativity-and-precedence","text":"Precendence information on operators may be obtained from GHCi with the :info command. GHCi returns: Type information; Infix or prefix; If infix, then its precedence and associativity; : info ( * ) For the multiplication operator ( * ) GHCi returns infixl 7 * infixl means that the operator ( * ) is an infix operator and is left associative. 7 is ( * ) 's precendece level (between 0-9). * is the operator's name, i.e. multiplication. Associativity Left Associativity For some left associative operator like ( * ) , an expression such as 1 * 3 * 5 is equivalent to (1 * 3) * 5 with parentheses denoting evaluation order, from left to right. Right Associativity For some right associative oerator like ( ^ ) , an expression such as 1 ^ 3 ^ 5 is equivalent to 1 ^ (3 ^ 5) , from right to left.","title":"Associativity and Precedence"},{"location":"2-haskell-basics/notes/#value-declaration","text":"In a Haskell source file {filename}.hs , -- file: arith.hs module Arith where addOne x = x + 1 fileName.hs declares a module Arith . Module name is capitalized and named with PascalCase . Function, variable and parameter names use camelCase .","title":"Value Declaration"},{"location":"2-haskell-basics/notes/#arithmetic-functions","text":"Operator Name Usage ( + ) Plus Addition ( - ) Minus Subtraction ( * ) Asterisk Multiplication ( / ) Slash Fractional division div Divide Integral division, round down mod Modulo Modulo division quot Quotient Integral division, round towards zero rem Remainder Remainder after division","title":"Arithmetic Functions"},{"location":"2-haskell-basics/notes/#negative-numbers","text":"Because ( - ) is an operator, negative numbers may need parentheses to disambiguate. Negative Integer 100 + ( - 9 )","title":"Negative Numbers"},{"location":"2-haskell-basics/notes/#dollar-operator","text":"The ( $ ) operator has the signature ( $ ) :: ( a -> b ) -> a -> b f $ a = f a GHCi gives infixr 0 $ upon using the : info command. It is right associative, and of the lowest possible precedence. This operator helps to reduce the number of parentheses: ( 2 ^ ) ( 2 + 2 ) == ( 2 ^ ) $ 2 + 2 The binary arithmetic operators can be partially applied (e.g. (2^) ), and this is called sectioning .","title":"Dollar ($) Operator"},{"location":"2-haskell-basics/notes/#let-and-where","text":"The let keyword is part of a let binding expression, while the where keyword is part of a where clause declaration. Both let and where allows extracting parts of an expression and giving them names. Where example printHello name = print greeting where greeting = \"Hello \" ++ name ++ \"!\" Let example printHello name = let greeting = \"Hello \" ++ name ++ \"!\" in print greeting","title":"Let and Where"},{"location":"3-strings/notes/","text":"Strings \u00b6 Types \u00b6 Types are ways to categorize values. Finding type information using GHCi Prelude > : type 'a' 'a' :: Char For Strings, such as \"Hello World\" , Prelude > : type \"Hello World\" \"Hello World\" :: [ Char ] Here String is a type alias for [ Char ] , a list of characters. Printing Strings \u00b6 Functions such as print may be used to print String s and other data types to the console. putStr and putStrLn are specialized for String data type. IO Type \u00b6 The IO type standards for Input/Output, and represents effects which are not pure. Do syntax The do syntax sequences actions: main :: IO () main = do putStrLn \"1. action 1\" putStrLn \"2. action 2\" putStrLn \"3. action 3\" Concatenating Strings \u00b6 The concatenation operator ( ++ ) may be used to concat two strings (or lists of Char s together). It has the type signature ( ++ ) :: [ a ] -> [ a ] -> [ a ] That is, it takes two lists of some arbitary type a and combines them to give a single combined list of a s. Such arbitary type is a wildcard type, which can be any type. Since it is the same type variable a throughout, the input lists and output list must have elements of the same type a . String concatenation operator Prelude > \"Hello \" ++ \"World!\" Hello World ! The concat function can also be used to combine some Foldable list with elements of arbitary type a . concat :: Foldable t => t [ a ] -> [ a ] String concat Prelude > concat [ \"Hello\" , \" \" , \"World!\" ] Hello World ! Lists \u00b6 Prepend \u00b6 The cons operator ( : ) prepends an element to a list (of the same type). ( : ) :: a -> [ a ] -> [ a ] Getting first element \u00b6 The head function returns the first element of a list. head :: [ a ] -> a What if the list is empty? Haskell will through an exception should the list be empty. It may be wise to wrap the head function into a safeHead function where safeHead :: [ a ] -> Maybe a safeHead [] = Nothing safeHead ( x : xs ) = Just x Getting every element except for the first \u00b6 The tail function returns all elements but the first element of a list. tail :: [ a ] -> [ a ] Empty list Similar to head, Haskell will also throw exception if list is empty. A safe version safeTail can also be used where safeTail :: [ a ] -> Maybe [ a ] safeTail [] = Nothing safeTail ( x : xs ) = Just xs Getting some specified number of elements \u00b6 The take function returns a selected number of elements, counting from the left. take :: Int -> [ a ] -> [ a ] Keeping a specified number of elements \u00b6 The drop function discards a selected number of elements, counting from the left, and returns the remainder. drop :: Int -> [ a ] -> a Indexing \u00b6 The ( !! ) infix indexing operator returns the element in the specified position with the index starting from 0. ( !! ) :: [ a ] -> Int -> a","title":"Strings"},{"location":"3-strings/notes/#strings","text":"","title":"Strings"},{"location":"3-strings/notes/#types","text":"Types are ways to categorize values. Finding type information using GHCi Prelude > : type 'a' 'a' :: Char For Strings, such as \"Hello World\" , Prelude > : type \"Hello World\" \"Hello World\" :: [ Char ] Here String is a type alias for [ Char ] , a list of characters.","title":"Types"},{"location":"3-strings/notes/#printing-strings","text":"Functions such as print may be used to print String s and other data types to the console. putStr and putStrLn are specialized for String data type.","title":"Printing Strings"},{"location":"3-strings/notes/#io-type","text":"The IO type standards for Input/Output, and represents effects which are not pure. Do syntax The do syntax sequences actions: main :: IO () main = do putStrLn \"1. action 1\" putStrLn \"2. action 2\" putStrLn \"3. action 3\"","title":"IO Type"},{"location":"3-strings/notes/#concatenating-strings","text":"The concatenation operator ( ++ ) may be used to concat two strings (or lists of Char s together). It has the type signature ( ++ ) :: [ a ] -> [ a ] -> [ a ] That is, it takes two lists of some arbitary type a and combines them to give a single combined list of a s. Such arbitary type is a wildcard type, which can be any type. Since it is the same type variable a throughout, the input lists and output list must have elements of the same type a . String concatenation operator Prelude > \"Hello \" ++ \"World!\" Hello World ! The concat function can also be used to combine some Foldable list with elements of arbitary type a . concat :: Foldable t => t [ a ] -> [ a ] String concat Prelude > concat [ \"Hello\" , \" \" , \"World!\" ] Hello World !","title":"Concatenating Strings"},{"location":"3-strings/notes/#lists","text":"","title":"Lists"},{"location":"3-strings/notes/#prepend","text":"The cons operator ( : ) prepends an element to a list (of the same type). ( : ) :: a -> [ a ] -> [ a ]","title":"Prepend"},{"location":"3-strings/notes/#getting-first-element","text":"The head function returns the first element of a list. head :: [ a ] -> a What if the list is empty? Haskell will through an exception should the list be empty. It may be wise to wrap the head function into a safeHead function where safeHead :: [ a ] -> Maybe a safeHead [] = Nothing safeHead ( x : xs ) = Just x","title":"Getting first element"},{"location":"3-strings/notes/#getting-every-element-except-for-the-first","text":"The tail function returns all elements but the first element of a list. tail :: [ a ] -> [ a ] Empty list Similar to head, Haskell will also throw exception if list is empty. A safe version safeTail can also be used where safeTail :: [ a ] -> Maybe [ a ] safeTail [] = Nothing safeTail ( x : xs ) = Just xs","title":"Getting every element except for the first"},{"location":"3-strings/notes/#getting-some-specified-number-of-elements","text":"The take function returns a selected number of elements, counting from the left. take :: Int -> [ a ] -> [ a ]","title":"Getting some specified number of elements"},{"location":"3-strings/notes/#keeping-a-specified-number-of-elements","text":"The drop function discards a selected number of elements, counting from the left, and returns the remainder. drop :: Int -> [ a ] -> a","title":"Keeping a specified number of elements"},{"location":"3-strings/notes/#indexing","text":"The ( !! ) infix indexing operator returns the element in the specified position with the index starting from 0. ( !! ) :: [ a ] -> Int -> a","title":"Indexing"},{"location":"4-basic-datatypes/notes/","text":"Basic Datatypes \u00b6 Types (Datatypes) \u00b6 Types (or datatypes ) introduces discipline in the inputs and outputs of functions. They restrict what inputs and outputs can be \u2014 which provides valuable information. Types, when used properly, can help to accomplish more with less code. Types are how similar values are grouped together by finding commonality. Such commonality may be abstract. Data declaration \u00b6 A type may be declared with: Datatypes are defined via data declarations . Type constructor is the name of the type. Data constructors are the values which may show up at the term level instead of the type level . Bool Type \u00b6 The datatype Bool represents the boolean values. data Bool = False | True Bool is the name of the type, and is the type constructor . False and True are the two value constructors which are the only possible values that the Bool type may take. The pipe | indicates sum type (i.e. either False or True ). Numeric Types \u00b6 Haskell has multiple numeric types, but the commonly used ones can be classified into Integral numbers and Fractional numbers. Integral numbers: Int : fixed-precision integer. Integer : arbitary-precision integer. Fractional numbers: Float : single-precision floating point number. Double : double-precision floating point number. Rational : fractional number which represents ratio between two integers; arbitary precision. Scientific : space-efficient and almost-arbitary-precision, represented via Scientific notation, with the coefficient being Integer and exponent as Int . All of such numeric types are instances of the Num typeclass . A typeclass adds functionality to types which shall be shared by instances of such typeclass. Num is the typeclass for these numeric types as the numbers share operations such as ( + ) , ( - ) , ( * ) . Each instance specifies how such operations behave with respect to the type. The minBound and maxBound functions can be used to find the min and max bounds for numeric types which are instances of the Bounded typeclass. Comparing Values \u00b6 Testing for equality (inequality) between two values which are of types that are instances of the Eq typeclass (i.e. values which have the notion of \"equality\"): -- Equality ( == ) :: Eq a => a -> a -> Bool -- Inequality ( /= ) :: Eq a => a -> a -> Bool Testing for order (less than, more than) between two values which are of types that are instances of the Ord typeclass (i.e. values which have the notion of \"order\"). -- Less than ( < ) :: Ord a => a -> a -> Bool -- More than ( > ) :: Ord a => a -> a -> Bool Bool Functions and Operators \u00b6 The boolean algebra functions and operators: -- Negation / not not :: Bool -> Bool -- And ( && ) :: Bool -> Bool -> Bool -- Or ( || ) :: Bool -> Bool -> Bool Conditionals \u00b6 Haskell only has if expressions but not statements: if CONDITION then EXPRESSION_A else EXPRESSION_B This expression reduces to EXPRESSION_A or EXPRESSION_B depending on the CONDITION . It is similar to ternary expressions in other languages such as JavaScript: ( 1 + 1 == 2 ) ? \"Hello World\" : \"Goodbye World\" ; // -> \"Hello World\" Tuples \u00b6 Tuples allows combining multiple values grouped up in one value. It is also known as a product type , which represents conjunction \u2014 all constituents are required to successfully construct the tuple type. A n-tuple is said to have n constituents. For exmaple, a 2-tuple has two components, (x, y) . The number of constituents of a tuple is known as its arity . Constituents of a tuple do not have to be of the same type. 2-tuple \u00b6 A 2-tuple's datatype declaration is given by: (,) :: a -> b -> ( a , b ) And also data (,) a b = (,) a b Convience functions, namely fst and snd allows easy extraction of the first and second values out of the tuple respectively. fst :: ( a , b ) -> a snd :: ( a , b ) -> b","title":"Basic Datatypes"},{"location":"4-basic-datatypes/notes/#basic-datatypes","text":"","title":"Basic Datatypes"},{"location":"4-basic-datatypes/notes/#types-datatypes","text":"Types (or datatypes ) introduces discipline in the inputs and outputs of functions. They restrict what inputs and outputs can be \u2014 which provides valuable information. Types, when used properly, can help to accomplish more with less code. Types are how similar values are grouped together by finding commonality. Such commonality may be abstract.","title":"Types (Datatypes)"},{"location":"4-basic-datatypes/notes/#data-declaration","text":"A type may be declared with: Datatypes are defined via data declarations . Type constructor is the name of the type. Data constructors are the values which may show up at the term level instead of the type level .","title":"Data declaration"},{"location":"4-basic-datatypes/notes/#bool-type","text":"The datatype Bool represents the boolean values. data Bool = False | True Bool is the name of the type, and is the type constructor . False and True are the two value constructors which are the only possible values that the Bool type may take. The pipe | indicates sum type (i.e. either False or True ).","title":"Bool Type"},{"location":"4-basic-datatypes/notes/#numeric-types","text":"Haskell has multiple numeric types, but the commonly used ones can be classified into Integral numbers and Fractional numbers. Integral numbers: Int : fixed-precision integer. Integer : arbitary-precision integer. Fractional numbers: Float : single-precision floating point number. Double : double-precision floating point number. Rational : fractional number which represents ratio between two integers; arbitary precision. Scientific : space-efficient and almost-arbitary-precision, represented via Scientific notation, with the coefficient being Integer and exponent as Int . All of such numeric types are instances of the Num typeclass . A typeclass adds functionality to types which shall be shared by instances of such typeclass. Num is the typeclass for these numeric types as the numbers share operations such as ( + ) , ( - ) , ( * ) . Each instance specifies how such operations behave with respect to the type. The minBound and maxBound functions can be used to find the min and max bounds for numeric types which are instances of the Bounded typeclass.","title":"Numeric Types"},{"location":"4-basic-datatypes/notes/#comparing-values","text":"Testing for equality (inequality) between two values which are of types that are instances of the Eq typeclass (i.e. values which have the notion of \"equality\"): -- Equality ( == ) :: Eq a => a -> a -> Bool -- Inequality ( /= ) :: Eq a => a -> a -> Bool Testing for order (less than, more than) between two values which are of types that are instances of the Ord typeclass (i.e. values which have the notion of \"order\"). -- Less than ( < ) :: Ord a => a -> a -> Bool -- More than ( > ) :: Ord a => a -> a -> Bool","title":"Comparing Values"},{"location":"4-basic-datatypes/notes/#bool-functions-and-operators","text":"The boolean algebra functions and operators: -- Negation / not not :: Bool -> Bool -- And ( && ) :: Bool -> Bool -> Bool -- Or ( || ) :: Bool -> Bool -> Bool","title":"Bool Functions and Operators"},{"location":"4-basic-datatypes/notes/#conditionals","text":"Haskell only has if expressions but not statements: if CONDITION then EXPRESSION_A else EXPRESSION_B This expression reduces to EXPRESSION_A or EXPRESSION_B depending on the CONDITION . It is similar to ternary expressions in other languages such as JavaScript: ( 1 + 1 == 2 ) ? \"Hello World\" : \"Goodbye World\" ; // -> \"Hello World\"","title":"Conditionals"},{"location":"4-basic-datatypes/notes/#tuples","text":"Tuples allows combining multiple values grouped up in one value. It is also known as a product type , which represents conjunction \u2014 all constituents are required to successfully construct the tuple type. A n-tuple is said to have n constituents. For exmaple, a 2-tuple has two components, (x, y) . The number of constituents of a tuple is known as its arity . Constituents of a tuple do not have to be of the same type.","title":"Tuples"},{"location":"4-basic-datatypes/notes/#2-tuple","text":"A 2-tuple's datatype declaration is given by: (,) :: a -> b -> ( a , b ) And also data (,) a b = (,) a b Convience functions, namely fst and snd allows easy extraction of the first and second values out of the tuple respectively. fst :: ( a , b ) -> a snd :: ( a , b ) -> b","title":"2-tuple"},{"location":"5-types/notes/","text":"Types \u00b6 Haskell implements pure (typed) lambda calculus. Haskell improves on System F and Hindley-Milner type system for type inference. Type systems enforce enstrictions to ensure correctness. Haskell is statically typed, meaning types are checked at compile time, catching errors early. Types can also help optimizations. Types are good documentation. Type Polymorphism \u00b6 Type variables such as Num a => a can be constrained. Here, type a is required to be an instance of the Num typeclass. This is called constrained polymorphism. Such a is called a typeclass-constrained type variable. Function Type \u00b6 The arrow operator ( -> ) is the type constructor for functions. data ( -> ) a b Typeclass Constraints \u00b6 As previously mentioned, a polymorphic type variable may be constrained by typeclass(-es). Num a => a ( Num a , Num b ) => a -> b -> b Currying \u00b6 Currying allows the innermost body expression to have access to the value of multiple arguments by nesting lambdas (even though each lambda only has one argument). Having some function such as fn :: a -> a -> a When one argument is supplied to fn , a new function of type a -> a is returned with the previous argument filled in. fn :: a -> ( a -> a ) Would be more accurate, but since ( -> ) is right associative, the parentheses may be dropped. Functions can also take other functions as argument (i.e. higher-order functions ). map :: ( a -> b ) -> [ a ] -> [ b ] Here the parentheses is necessary to group the ( a -> b ) part to designate it as a function as single argument and not two distinct arguments. Partial Application \u00b6 If some function is curried, e.g. map , then part of the arguments can be filled in. For example, we can supply the identity function id x = x to map . id :: a -> a id x = x mapId :: [ a ] -> [ b ] mapId xs = map id xs Notice that: map id , map applied to id , has the type [ a ] -> [ b ] which is identical to that of mapId . mapId does nothing to xs apart from passing it to map id . This means that xs can be omitted, and mapId can simply be defined as an alias to the partiall-applied map id . mapId :: [ a ] -> [ b ] mapId = map id This is called point-free style. Sectioning \u00b6 Partially applying infix operators is called sectioning . Sectioning addOne :: Num a => a -> a addOne = ( + 1 ) Here ( + 1 ) is the addition ( + ) partially applied with 1 . Since ( + ) is commutative, ( + 1 ) == ( 1 + ) , but ( - 2 ) /= ( 2 - ) since ( - ) is not commutative. Polymorphism \u00b6 Polymorphic type variables allows expressions to work with arbitary types, so we don't need to implement such expression for every type we need to it work with. Haskell polymorphism is classified into: Parametric polymorphism . Constrained polymorphism . Parametric polymorphism is more broad than constrained polymorphism since it places less restrictions. The identity function id :: a -> a Is maximally polymorphic since it works with any data. But id cannot do anything with a other than to return it because it has no information on a . When the type variable is constrained by a typeclass, it can take less types but also comes with a set of operations which can be used on the argument. Concrete types can be instances of multiple typeclasses, and typeclasses can be superclasses of typeclasses. Such typeclasses are additive in nature in that by becoming instances of typeclasses, one inherits their defined operations. Type Inference \u00b6 Haskell's type inference is extended from the Damas-Hindley-Milner type system. Haskell tries to infer the most polymorphic / general type possible while ensuring correctness.","title":"Types"},{"location":"5-types/notes/#types","text":"Haskell implements pure (typed) lambda calculus. Haskell improves on System F and Hindley-Milner type system for type inference. Type systems enforce enstrictions to ensure correctness. Haskell is statically typed, meaning types are checked at compile time, catching errors early. Types can also help optimizations. Types are good documentation.","title":"Types"},{"location":"5-types/notes/#type-polymorphism","text":"Type variables such as Num a => a can be constrained. Here, type a is required to be an instance of the Num typeclass. This is called constrained polymorphism. Such a is called a typeclass-constrained type variable.","title":"Type Polymorphism"},{"location":"5-types/notes/#function-type","text":"The arrow operator ( -> ) is the type constructor for functions. data ( -> ) a b","title":"Function Type"},{"location":"5-types/notes/#typeclass-constraints","text":"As previously mentioned, a polymorphic type variable may be constrained by typeclass(-es). Num a => a ( Num a , Num b ) => a -> b -> b","title":"Typeclass Constraints"},{"location":"5-types/notes/#currying","text":"Currying allows the innermost body expression to have access to the value of multiple arguments by nesting lambdas (even though each lambda only has one argument). Having some function such as fn :: a -> a -> a When one argument is supplied to fn , a new function of type a -> a is returned with the previous argument filled in. fn :: a -> ( a -> a ) Would be more accurate, but since ( -> ) is right associative, the parentheses may be dropped. Functions can also take other functions as argument (i.e. higher-order functions ). map :: ( a -> b ) -> [ a ] -> [ b ] Here the parentheses is necessary to group the ( a -> b ) part to designate it as a function as single argument and not two distinct arguments.","title":"Currying"},{"location":"5-types/notes/#partial-application","text":"If some function is curried, e.g. map , then part of the arguments can be filled in. For example, we can supply the identity function id x = x to map . id :: a -> a id x = x mapId :: [ a ] -> [ b ] mapId xs = map id xs Notice that: map id , map applied to id , has the type [ a ] -> [ b ] which is identical to that of mapId . mapId does nothing to xs apart from passing it to map id . This means that xs can be omitted, and mapId can simply be defined as an alias to the partiall-applied map id . mapId :: [ a ] -> [ b ] mapId = map id This is called point-free style.","title":"Partial Application"},{"location":"5-types/notes/#sectioning","text":"Partially applying infix operators is called sectioning . Sectioning addOne :: Num a => a -> a addOne = ( + 1 ) Here ( + 1 ) is the addition ( + ) partially applied with 1 . Since ( + ) is commutative, ( + 1 ) == ( 1 + ) , but ( - 2 ) /= ( 2 - ) since ( - ) is not commutative.","title":"Sectioning"},{"location":"5-types/notes/#polymorphism","text":"Polymorphic type variables allows expressions to work with arbitary types, so we don't need to implement such expression for every type we need to it work with. Haskell polymorphism is classified into: Parametric polymorphism . Constrained polymorphism . Parametric polymorphism is more broad than constrained polymorphism since it places less restrictions. The identity function id :: a -> a Is maximally polymorphic since it works with any data. But id cannot do anything with a other than to return it because it has no information on a . When the type variable is constrained by a typeclass, it can take less types but also comes with a set of operations which can be used on the argument. Concrete types can be instances of multiple typeclasses, and typeclasses can be superclasses of typeclasses. Such typeclasses are additive in nature in that by becoming instances of typeclasses, one inherits their defined operations.","title":"Polymorphism"},{"location":"5-types/notes/#type-inference","text":"Haskell's type inference is extended from the Damas-Hindley-Milner type system. Haskell tries to infer the most polymorphic / general type possible while ensuring correctness.","title":"Type Inference"}]}